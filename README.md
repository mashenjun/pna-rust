# pna-rust
Practical Networked Applications in Rust

---

如何实现 read write lock free?  
提交作业的时候，只是用了`pread()`和`RwLock<T>`保证了读和读不冲突以及读和写的并发安全。
但这并没有满足read write lock free的要求。回头想了下到底该如何实现read write lock free，在此记录下思路。(可能这个思路完全是错的)  
由于我们是基于`BitCask`实现的存储方案。整体上有三种操作（读操作，写操作，压缩操作）。  
1. 读操作的逻辑：读取索引记录，根据索引读取log文件。 
2. 写操作的逻辑：追加log文件，更新索引记录。 
3. 压缩操作的逻辑：根据旧的索引记录和log文件计算出压缩后的索引记录和log文件，然后让读操作和写操作都用新的索引和log文件。  

我们发现操作之间的竞争关系主要在对索引和log文件的操作上。  
有一些常用的优化手段我们可以采用来帮助实现read write lock free。
1. 读写隔离。我们可以定义`Reader`负责读操作和`Writer`负责写操作。并让他们维护独立的fd来访问文件（读操作用`pread()`读取文件）。
2. 使用无锁数据结构。我们用`Arc<corssbeam-skiplist::SkipMap<K,V>>`来存储索引记录，并让`Reader`和`Writer`共用这个索引实例。

这两步优化采用后，读操作和读操作之间已经满足lock free，读操作和写操作之间也满足lock free。
剩下的问题是压缩操作和读操作之间的冲突（由于压缩操作是在每次写操作返回之前执行，用同一个Mutex统一保证互斥，所以压缩操作和写操作之间不用保证lock free）。  
这里核心问题在于：
1. 压缩操作是个耗时操作，在进行压缩操作的时候不能影响或阻塞`Reader`的读操作。
2. 压缩操作需要保证压缩后的log文件和索引在同一时刻对`Reader`可见，并且通知`Reader`用新的log文件和索引去做读操作。
`Reader`用新的索引记录读取旧的log文件或用旧的索引记录读取新的log文件都会读到错误数据。

这里我们可以采用维护双副本并交替更新的方案。
我们可以让`Reader`维护一个`cnt: AtomicU8`和`left: T`，`right: T`两个副本（每个副本都包含log文件句柄和索引记录）。
`cnt`控制`Reader`使用`left`还是`right`副本进行读操作（`cnt==0`使用`left`, `cnt==1`使用`right`）。读操作和压缩操作的流程就变成如下：  
1. 读操作：读取`cnt`的值，决定使用哪个副本。读取索引记录，根据索引读取log文件。  
2. 压缩操作：假设当前`cnt==0`，`Reader`使用`left`做读操作。那么压缩过程中计算的新的索引和log文件就会更新到`right`副本上（此时`right`上没有任何的读操作）。
当压缩操作完成后，修改`cnt=1`。这样下一次的读操作就会使用新的log文件和索引。  

我们知道如果要满足lock free，`Reader`的所有方法都应该都是不可变方法，利用内部可变性去更新内部状态。`SkipMap`已经实现了内部可变，所以对索引的更新没有问题。
但是对文件句柄的更新会破坏内部可变性。
一种方案是`Reader`只维护当前的文件ID，每次读操作的时候打开文件ID对应的文件进行读取。这样只再使用`AtomicU64`就能保证内部可变性。
但是个人认为这个方案有个问题：当读请求并发量变高时，进程的open_fd数量也会上升，最后可能超过上限而出错。  
所以我还是让`Reader`维护文件句柄，然后使用`crossbeam::AtomicCell<File>`来保证内部可变性。（由于File没有实现Clone，所以通过AtomicCell获取File涉及到unsafe code） 
